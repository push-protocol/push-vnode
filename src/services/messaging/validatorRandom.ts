// noinspection UnnecessaryLocalVariableJS

import { Inject, Service } from 'typedi'
import { NodeInfo, ValidatorContractState } from '../messaging-common/validatorContractState'
import { ValidatorClient } from './validatorClient'
import { PromiseUtil } from '../../utilz/promiseUtil'
import { Logger } from 'winston'
import {DateUtil} from  '../../utilz/dateUtil'
import schedule from 'node-schedule'
import { PingReply, PingStatus, ValidatorPing } from './validatorPing'
import { RandomUtil } from '../../utilz/randomUtil'
import { EthUtil } from '../../utilz/ethUtil'
import crypto from 'crypto'
import { BitUtil } from '../../utilz/bitUtil'
import {StrUtil} from '../../utilz/strUtil'
import { WinstonUtil } from '../../utilz/winstonUtil'
import { EnvLoader } from '../../utilz/envLoader'
import { Check } from '../../utilz/check'
import {BlockUtil} from "../messaging-common/blockUtil";



/**
 * Creates a RANDAO: a random number, generated by cluster
 * Applies a determenistic function to get ValidatorVector
 * Later our network executes validate/attest accroding to ValidatorVector
 */
@Service()
export class ValidatorRandom {
  private static readonly RANDOM_SIZE_IN_BYTES = 20;
  public static readonly ATT_TOKEN_PREFIX = BlockUtil.ATT_TOKEN_PREFIX;
  public static readonly VAL_TOKEN_PREFIX =  BlockUtil.VAL_TOKEN_PREFIX;

  // PING: schedule
  private static readonly RANDOM_SCHEDULE = '*/30 * * * * *'

  public static log: Logger = WinstonUtil.newLog(ValidatorRandom)

  @Inject((type) => ValidatorContractState)
  private contractState: ValidatorContractState

  @Inject((type) => ValidatorPing)
  private validatorPing: ValidatorPing

  private randomMap: Map<string, NodeRandom> = new Map()

  public postConstruct() {
    // every 10 second
    const validatorRanom = this
    const cronJob = schedule.scheduleJob(ValidatorRandom.RANDOM_SCHEDULE, async function () {
      try {
        validatorRanom.updateNetworkRandom()
      } catch (e) {
        console.log('updateNetworkRandom scheduled job error:', e)
      }
    })
    setTimeout(() => {
      cronJob.invoke()
    }, 6000)
    ValidatorRandom.log.level = 'error' // todo
    this.validatorPing.log.level = 'error' // todo
  }

  public async nodeRandom(): Promise<NodeRandom> {
    const nodeId = this.contractState.nodeId
    const randomHex = RandomUtil.getRandomBytesAsHex(ValidatorRandom.RANDOM_SIZE_IN_BYTES)
    const pingResults = Array.from(this.validatorPing.getPingState().values())
    const randomReply = new NodeRandom(nodeId, randomHex, pingResults)
    randomReply.signature = await EthUtil.create(this.contractState.wallet, randomReply)
    return randomReply
  }

  public async updateNetworkRandom() {
    const validators = this.contractState.getActiveValidatorsExceptSelf()
    const promiseList: Promise<NodeRandom>[] = []
    for (const v of validators) {
      const vc = new ValidatorClient(v.url)
      const promise = vc.random()
      promiseList.push(promise)
    }
    const prList = await PromiseUtil.allSettled(promiseList)
    for (let i = 0; i < validators.length; i++) {
      const v = validators[i]
      const oldRandom = this.randomMap.get(v.nodeId)
      const newRandom = prList[i].isSuccess() ? prList[i].val : null
      // handle update
      if (newRandom != null) {
        this.randomMap.set(v.nodeId, newRandom) // todo we grab timestamp from remote node
      } else {
        // NOTE: all the http errors ARE IGNORED here
        // don't do anything with older random values
        // todo ? remove if this one is older than 15mins?
      }
    }
    const newRandomFromSelf = await this.nodeRandom()
    this.randomMap.set(this.contractState.nodeId, newRandomFromSelf)
  }

  public async getNetworkRandom(): Promise<NetworkRandom> {
    const nr = new NetworkRandom()
    nr.nodes = Array.from(this.randomMap.values())
    return nr
  }

  // returns a token which defines which (1) validator can be queried
  public createValidatorToken(): ValidatorToken {
    const nr = this.getNetworkRandomForValidatorToken()
    const validationVector = ValidatorRandom.createValidationVector(this.contractState.getValidatorNodesMap(), 1, nr, 'client', this.contractState.contractCli.nodeRandomMinCount, this.contractState.contractCli.nodeRandomPingCount, [])
    if (validationVector == null) {
      throw new Error('failed to create validation vector')
    }
    const result = new ValidatorToken()
    const v1 = validationVector[0]
    result.validatorToken = ValidatorRandom.VAL_TOKEN_PREFIX + NetworkRandom.write(nr);
    result.validatorUrl = this.contractState.getValidatorNodesMap().get(v1).url;
    return result
  }

  // todo seed can be uniq for each call
  // todo update this.randomMap with a new NodeRandom (this.nodeId) every N calls
  private getNetworkRandomForValidatorToken() {
    if (this.randomMap.size == 0) {
      throw new Error('random not synced')
    }
    const nr = NetworkRandom.readMap(this.randomMap)
    return nr
  }

  // checks that token - leads to a (1) validator - nodeIdTarget
  public checkValidatorToken(validatorToken: string, expectedNodeId: string): boolean {
    if (StrUtil.isEmpty(validatorToken) || !validatorToken.startsWith(ValidatorRandom.VAL_TOKEN_PREFIX)) {
      ValidatorRandom.log.error('invalid validator token; should start with %s %s', ValidatorRandom.VAL_TOKEN_PREFIX, validatorToken);
      return false;
    }
    validatorToken = validatorToken.substring(ValidatorRandom.VAL_TOKEN_PREFIX.length);
    const nr = NetworkRandom.read(validatorToken);
    const validationVector = ValidatorRandom.createValidationVector(this.contractState.getValidatorNodesMap(), 1, nr, 'client', this.contractState.contractCli.nodeRandomMinCount, this.contractState.contractCli.nodeRandomPingCount, [])
    ValidatorRandom.log.debug('recovered attest vector %s', StrUtil.fmt(validationVector));
    const actual = validationVector && validationVector.length == 1 ? validationVector[0] : null;
    const success = actual === expectedNodeId;
    return success;
  }

  // for validator
  public createAttestToken(): AttestToken {
    if (this.randomMap.size == 0) {
      throw new Error('random not synced')
    }

    const nr = NetworkRandom.readMap(this.randomMap)
    const attestVector = ValidatorRandom.createValidationVector(this.contractState.getValidatorNodesMap(), this.contractState.contractCli.valPerBlock - 1, nr, 'attest', this.contractState.contractCli.nodeRandomMinCount, this.contractState.contractCli.nodeRandomPingCount, [this.contractState.nodeId])
    if (attestVector == null) {
      throw new Error('failed to create attest vector')
    }
    const t = new AttestToken(ValidatorRandom.ATT_TOKEN_PREFIX + NetworkRandom.write(nr), attestVector)
    return t
  }

  // for attester
  public checkAttestToken(
    nodeId: string,
    validatorToExclude: string,
    attestTokenBase64: string
  ): boolean {
    Check.isTrue(validatorToExclude == validatorToExclude, 'validator=nodeIdForLookup');
    if (StrUtil.isEmpty(attestTokenBase64) || !attestTokenBase64.startsWith(ValidatorRandom.ATT_TOKEN_PREFIX)) {
      ValidatorRandom.log.error('invalid attest token; should start with ' + ValidatorRandom.ATT_TOKEN_PREFIX);
      return false;
    }
    attestTokenBase64 = attestTokenBase64.toString().substring(ValidatorRandom.ATT_TOKEN_PREFIX.length);
    ValidatorRandom.log.debug('checkAttestToken:() nodeIdForLookUp: %s validatorNodeId:%s attestTokenBase64: %s',
      nodeId, validatorToExclude, this.contractState.contractCli.nodeRandomMinCount, attestTokenBase64);
    const nr = NetworkRandom.read(attestTokenBase64)
    const attestVector = ValidatorRandom.createValidationVector(this.contractState.getValidatorNodesMap(), this.contractState.contractCli.valPerBlock - 1, nr, 'attest', this.contractState.contractCli.nodeRandomMinCount, this.contractState.contractCli.nodeRandomPingCount, [validatorToExclude])
    ValidatorRandom.log.debug('recovered attest vector %s', StrUtil.fmt(attestVector));
    if (attestVector == null) {
      return false
    }
    for (const nodeId of attestVector) {
      if (nodeId === nodeId) {
        return true
      }
    }
    return false
  }

  /**
   * figure out which validators to use
   * based on: validatorsRequired,  networkRandom, allValidators
   *
   * checks that network random is valid
   *
   * The output is completely random, so:
   * 1 can return duplicates
   * 2 can return first address at any position
   *
   * @param allValidators all validators defined on a smart contract
   * @param validatorsRequired how many do we need
   * @param networkRandom a network random
   * @param seed
   * @param nodeRandomRequired how many random replies are needed so that network random is viable
   * @param nodeRandomPingRequired we will filter nodeIds random replies, if they don't have enough pings
   * from other peers (i.e. we don't like offline members)
   * @param nodesToSkip this is node id from allValidators that should be skipped;
   * this allows to re-use the same list/map of validators for any block
   * If I can make a copy for every validator this param can be removed.
   * @returns a list of nodeIds
   */
  public static createValidationVector(
    allValidators: Map<string, NodeInfo>,
    validatorsRequired: number,
    networkRandom: NetworkRandom,
    seed: string,
    nodeRandomRequired: number,
    nodeRandomPingRequired: number,
    nodesToSkip: string[]
  ): string[] | null {
    const goodNodesOnline: string[] = []
    const randomMap: Map<string, NodeRandom> = new Map<string, NodeRandom>()
    for (const nodeRandom of networkRandom.nodes) {
      Check.notEmpty(nodeRandom.nodeId) // todo
      // todo Are these checks safe ???
      let goodTimestamp = nodeRandom.tsMillis > DateUtil.currentTimeMillis() - 60 * 60 * 1000
      if (EnvLoader.getPropertyAsBool('VALIDATOR_DISABLE_TOKEN_TIMEOUT')) {
        goodTimestamp = true
      }
      ValidatorRandom.log.error('nodeRandom from %s is outdated by more than 1hr', nodeRandom.nodeId)
      const validNodeId = allValidators.has(nodeRandom.nodeId)
      // todo on review stage: double check that we check the 'real thing' here
      const validSignature = EthUtil.check(nodeRandom.signature, nodeRandom.nodeId, nodeRandom)
      const validRandomHex = StrUtil.isHex(nodeRandom.randomHex)
      if (
        goodTimestamp &&
        validNodeId &&
        validSignature &&
        validRandomHex
      ) {
        goodNodesOnline.push(nodeRandom.nodeId)
        randomMap.set(nodeRandom.nodeId, nodeRandom)
      } else {
        ValidatorRandom.log.error(
          'invalid nodeRandom: %o, ' +
            'goodTimestamp: %s, validNodeId: %s, validSignature: %s,' +
            'validRandomHex: %o',
          nodeRandom,
          goodTimestamp,
          validNodeId,
          validSignature,
          validRandomHex
        )
      }
    }
    if (nodeRandomRequired != 0 && goodNodesOnline.length < nodeRandomRequired) {
      ValidatorRandom.log.error('not enough Node Random replies to build a random vector')
      throw new Error('not enough Node Random replies to build a random vector')
    }
    const mapIdToRandom = new Map<string, string>()
    for (const nodeId of goodNodesOnline) {
      mapIdToRandom.set(nodeId, randomMap.get(nodeId)?.randomHex)
    }
    const result = ValidatorRandom.calculateValidationVector(goodNodesOnline, mapIdToRandom, validatorsRequired, seed, nodesToSkip)
    ValidatorRandom.log.debug('created api token vector %s', StrUtil.fmt(result));
    return result
  }

  private static calculateSuccessfulPingCount(networkRandom: NetworkRandom): Map<string, number> {
    const successPingMap = new Map<string, number>()
    for (const nodeRandom of networkRandom.nodes) {
      for (const pingResult of nodeRandom.pingResults) {
        if (pingResult.nodeId == nodeRandom.nodeId) {
          continue
        }
        if (pingResult.status != PingStatus.ONLINE) {
          continue
        }
        let oldVal = successPingMap.get(nodeRandom.nodeId)
        const newVal = oldVal == null ? 1 : ++oldVal
        successPingMap.set(nodeRandom.nodeId, newVal)
      }
    }
    return successPingMap
  }

  /**
   * Chooses an ordered fixed amount of node ids out of list,
   * based on random values from every node.
   *
   * This funciton is DETERMENISTIC and SHOULD provide the same output for the input
   * no matter how many times/ on which nodes it is being executed.
   *
   * For determenistic results, these params should be fixed:
   * nodes
   * mapIdToRandom
   * randomNodesRequired
   * seed
   * nodesToSkip
   *
   * @param nodes array node nodeIds, i.e. [1,2,3]
   * @param mapIdToRandom  a mapping of nodeId->NodeRandom.randomHex value
   * @param randomNodesRequired number of uniq nodeIds to produce
   * @param seed seed , used to get different results when needed;
   * this should be empty to get same result for different nodes,
   * or it can be == nodeId to get different results for different nodes
   * @param nodesToSkip which nodeIds should be skipped
   * todo replace sha512 with shake_256 if arbitrary output size is needed (>50 signing nodes)
   */
  static calculateValidationVector(
    nodes: string[],
    mapIdToRandom: Map<string, string>,
    randomNodesRequired: number,
    seed: string,
    nodesToSkip: string[]
  ): string[] {
    if (randomNodesRequired < 1 || randomNodesRequired > 50) {
      throw new Error(
        'current function works only for 50 nodes, rndNodesRequired=' + randomNodesRequired
      )
    }
    if (randomNodesRequired > nodes.length) {
      throw new Error('generating possible duplicates')
    }
    if (nodes.length > mapIdToRandom.size) {
      throw new Error('mapIdToRandom is too small')
    }
    if (nodes.length > mapIdToRandom.size) {
      throw new Error('mapIdToRandom is too small')
    }
    if (nodes.length == 0) {
      throw new Error('not enough nodeIds')
    }
    if(nodes.length == 1) {
      return [nodes[0]];
    }
    Check.isTrue(nodes.length >= 1, `no nodes available`)
    const nodeArr = nodes.slice(0);

    ValidatorRandom.sortAsc(nodeArr)
    ValidatorRandom.log.info(`randomNodesRequired %s`, randomNodesRequired)
    ValidatorRandom.log.info(`nodes: %s`, StrUtil.fmt(nodeArr))
    // xor all random values (xor works like add, so the order doesn't really matter)
    const hasher = crypto.createHash('sha512').update(StrUtil.getOrDefault(seed, ''));
    for (const nodeId of nodeArr) {
      const randomHex = mapIdToRandom.get(nodeId)
      const tmp = Buffer.from(randomHex, 'hex')
      hasher.update(tmp);
    }
    const hash = hasher.digest();
    // collapse all into 512 bit / 64 bytes
    // let's assume that we will always have less than 50 signing nodes (8 bits per node)
    // so that we have enough randomness to read 64x times even with duplicates
    const hashSizeInNodeOffsets = 64; // 1byte
    const banSet = new Set<string>(nodesToSkip)
    const resultSet = new Set<string>()
    ValidatorRandom.log.info(`hashBytes %s`, StrUtil.fmt(hash));
    for (let i = 0; i < hashSizeInNodeOffsets && resultSet.size < randomNodesRequired; i++) {
      const random8bits = hash.readUInt8(i); // 1byte
      const randomNodeIndex = nodeArr.length == 0 ? 0 : random8bits % nodeArr.length
      const randomNodeId = nodeArr[randomNodeIndex]
      ValidatorRandom.log.debug(
        `random8bits %s, randomNodeIndex %s, randomNodeId %s, nodeArr: %s, resultSet: %o`,
        random8bits,
        randomNodeIndex,
        randomNodeId,
        StrUtil.fmt(nodeArr),
        StrUtil.fmt(resultSet)
      )
      Check.notNull(randomNodeId, `invalid random node at ${randomNodeIndex}`)
      nodeArr.splice(randomNodeIndex, 1) // use each only once
      if (banSet.has(randomNodeId)) {
        ValidatorRandom.log.debug('skipping id because of nodesToSkip')
      } else if (resultSet.has(randomNodeId)) {
        ValidatorRandom.log.debug('skipping id because of duplicate')
      } else {
        resultSet.add(randomNodeId)
      }
    }
    if (resultSet.size != randomNodesRequired) {
      throw new Error('failed to collect enough random nodes from networkRandom')
    }
    return Array.from(resultSet)
  }

  static sortAsc(arr: string[]) {
    if (arr != null) {
      arr.sort()
    }
  }
}

export class ValidatorVector {
  validators: NodeInfo[]
}

/*
{
"nodes": [
    {
        "nodeId": "0x8e12dE12C35eABf35b56b04E53C4E468e46727E8",
        "tsMillis": 1676813775673,
        "nodeRandom": "741d79026d9d63723f1b415e1a9ccc8e1880ec55fb6946316820cd07e2de0ee3",
        "pingResults": [
            {
                "nodeId": "0x8e12dE12C35eABf35b56b04E53C4E468e46727E8",
                "status": 1,
                "tsMillis": 1676813770023
            }
        ],
        "signature": "0x3b3d0c1f6f2b5004936b286373c54785aa997373410b886cd622fd0dc4f475f708c09432a74ecfbd124387aa440dc985403cfb548c58348c868d950f5dfbfc6d1c"
    }
],
"signature": "0x28cf821d06db65ac18fd452b636fec18f7825f22f17479ac8b14c0ae3436dc0530935145917e8aaee6dcb485cdfa1904464c2bab20b027d862b96b1fb6f884141c"
}
*/

/*
A network random value (just a big number):

Build from a collection of node random values (signed by every node)
Right now we store a lot of additional excessive info.
This can be reduced down to nodeId -> randomHex
*/
export class NetworkRandom {
  nodes: NodeRandom[]

  public static write(nr: NetworkRandom): string {
    return BitUtil.strToBase64(JSON.stringify(nr))
  }

  // check that every reply has a valid signature
  public static read(nr: string): NetworkRandom {
    let attToken = BitUtil.base64ToStr(nr);
    return <NetworkRandom>JSON.parse(attToken)
  }

  public static readMap(randomMap: Map<string, NodeRandom>): NetworkRandom {
    const nr = new NetworkRandom()
    nr.nodes = Array.from(randomMap.values())
    return nr
  }
}

/**
 * Represents a token which allows an SDK client to query a group of validators
 *
 * Build from a NetworkRandom
 */
export class ValidatorToken {
  // this is NetworkRandom packed as Base64
  // 1. defines which validators to query
  // 2. every validator can also verify his role, given a NetworkRandom
  validatorToken: string
  // this is which validator to query (it will call attesters later)
  validatorUrl: string
}

export class AttestToken {
  constructor(public attestToken: string, public attestVector: string[]) {
    this.attestToken = attestToken
    this.attestVector = attestVector
  }
}

/*
A single node random value
 */
export class NodeRandom {
  randomHex: string // a random number from that node
  signature: string // sign the whole structure

  // fields below are added for future use ; also a signature can be used instead of a randomHex
  nodeId: string // which node reported
  tsMillis: number // create timestamp in millis
  pingResults: PingReply[] // online/offline statues as the node sees its peers

  constructor(nodeId: string, randomHex: string, pingResults: PingReply[]) {
    this.nodeId = nodeId
    this.tsMillis = DateUtil.currentTimeMillis()
    this.randomHex = randomHex
    this.pingResults = pingResults
  }
}
